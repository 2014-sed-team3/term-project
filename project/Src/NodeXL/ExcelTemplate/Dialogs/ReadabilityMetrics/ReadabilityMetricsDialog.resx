<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="lnkGraphRectangleCoverage.Tag" xml:space="preserve">
    <value>Measures the fraction of the graph pane that is covered by vertices and edges.  This usually ranges from 0 (the graph pane is empty) to 1.0 (the graph pane is completely covered by vertices and edges).  In the rare case where a vertex is too large to fit in the graph pane, the value can exceed 1.0.

Note that NodeXL makes some approximations when it calculates the graph pane coverage.  It treats curved and bundled edges as straight lines, and it ignores label annotations, self-loop edges and edge arrowheads.  The actual coverage may therefore be somewhat greater than the coverage that NodeXL calculates, depending on the content of your graph.
	
The readability metrics are based on work done by Cody Dunne and Ben Shneiderman at the University of Maryland.</value>
  </data>
  <data name="lnkOverallEdgeCrossings.Tag" xml:space="preserve">
    <value>Measures how many times the graph's edges cross each other.  A value of 1.0 indicates no crossings and is ideal.  A value of 0 indicates maximum crossings and represents impaired readability.  The value gets written to the Overall Metrics worksheet.
	
The readability metrics are based on work done by Cody Dunne and Ben Shneiderman at the University of Maryland.</value>
  </data>
  <data name="lnkOverallVertexOverlap.Tag" xml:space="preserve">
    <value>Measures how much the graph's vertices overlap one another.  A value of 1.0 indicates no overlap and is ideal.  A value of 0 indicates maximum overlap and represents impaired readability.  The value gets written to the Overall Metrics worksheet.
	
The readability metrics are based on work done by Cody Dunne and Ben Shneiderman at the University of Maryland.</value>
  </data>
  <data name="lnkPerEdgeEdgeCrossings.Tag" xml:space="preserve">
    <value>Measures how many times an edge crosses the graph's other edges.  A value of 1.0 indicates no crossings and is ideal.  A value of 0 indicates maximum crossings and represents impaired readability.  The values get written to the Edges worksheet.
	
The readability metrics are based on work done by Cody Dunne and Ben Shneiderman at the University of Maryland.</value>
  </data>
  <data name="lnkPerVertexEdgeCrossings.Tag" xml:space="preserve">
    <value>Measures how many times a vertex's incident edges cross the graph's other edges.  A value of 1.0 indicates no crossings and is ideal.  A value of 0 indicates maximum crossings and represents impaired readability.  The values get written to the Vertices worksheet.
	
The readability metrics are based on work done by Cody Dunne and Ben Shneiderman at the University of Maryland.</value>
  </data>
  <data name="lnkPerVertexVertexOverlap.Tag" xml:space="preserve">
    <value>Measures how much a vertex overlaps the graph's other vertices.  A value of 1.0 indicates no overlap and is ideal.  A value of 0 indicates maximum overlap and represents impaired readability.  The values get written to the Vertices worksheet.
	
The readability metrics are based on work done by Cody Dunne and Ben Shneiderman at the University of Maryland.</value>
  </data>
</root>
